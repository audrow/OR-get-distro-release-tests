import {parse} from 'csv/sync'
import endent from 'endent'
import fs from 'fs'
import yaml from 'js-yaml'
import {basename, join} from 'path'
import {validateRequirementsYaml} from '../src/requirements/generator/utils'
import type Requirement from '../src/requirements/__types__/Requirement'

type Features = Record<string, string[]>

function getPackageExecutables(content: string) {
  const rawFeatures = parse(content)
  const features: Features = {}
  let lastPackage: string
  const warnings: string[] = []
  rawFeatures.forEach((record: string[2]) => {
    const [package_, executables] = record

    if (package_.trim() !== '') {
      lastPackage = package_.trim()
    }

    // Handle different formats used in CSV columns
    // The data file `executable-features.csv` needs to use `: ` to separate the package
    // and executables since there exists cases using parameter by `key:=value` for a launch file
    const splitExecutables = executables.split(': ')
    let currentPackage: string
    let currentExecutables: string[]
    if (splitExecutables.length === 2 && lastPackage.slice(-1) === '*') {
      // handle package_* format, where rest of package is specified in the executables field
      const packageSufix = splitExecutables[0].trim()
      currentPackage = lastPackage.slice(0, -1) + packageSufix
      currentExecutables = splitExecutables[1].split(',')
    } else if (splitExecutables.length === 1) {
      // this is the regular case where a package is specified in the package field, and is
      // not split across the executables field
      currentPackage = lastPackage
      currentExecutables = splitExecutables[0].split(',')
    } else {
      throw new Error(`Could not parse executables ${executables}`)
    }

    // Check for errors
    if (currentPackage.match(/\s/)) {
      warnings.push(`Package '${currentPackage}' contains spaces`)
    }
    if (currentExecutables.length === 0) {
      warnings.push(`No executables for package '${currentPackage}'`)
    }
    if (
      currentExecutables.length === 1 &&
      currentExecutables[0].toLowerCase() === 'demo'
    ) {
      warnings.push(
        `Package '${currentPackage}' has only demo executable - this is probably not what you want`,
      )
    }
    if (
      currentExecutables.length === 1 &&
      currentExecutables[0].toLowerCase() === 'examples'
    ) {
      warnings.push(
        `Package '${currentPackage}' has only examples executable - this is probably not what you want`,
      )
    }

    if (!features[currentPackage]) {
      features[currentPackage] = []
    }
    features[currentPackage].push(...currentExecutables.map((e) => e.trim()))
  })
  if (warnings.length > 0) {
    console.warn(endent`
      Warnings:
        ${warnings.map((e) => `* ${e}`).join('\n')}

      ${warnings.length} warnings in the executables
    `)
  } else {
    console.info('\nSuccessfully parsed executables with no warnings')
  }
  return features
}

function getRequirementsYaml(features: Features, labels: string[]) {
  const requirements = Object.entries(features).map((feature) => {
    const [packageName, executables] = feature
    const requirement: Requirement = {
      name: `Executables in \`${packageName}\``,
      labels: [...labels],
      checks: executables.map((executable) => {
        let command: string
        if (executable.match(/(ros2 launch)|(ros2 bag)/)) {
          // Deal with special cases that using `ros2 launch` or `ros2 bag`
          command = `${executable}`
        } else if (executable.match(/launch/)) {
          command = `ros2 launch ${packageName} ${executable}`
        } else {
          command = `ros2 run ${packageName} ${executable}`
        }
        return {
          name: `Check \`${executable}\``,
          try: [
            {
              stdin: command,
            },
          ],
          expect: [
            {
              note: 'It works.',
            },
          ],
        }
      }),
    }
    return requirement
  })
  const requirements_ = {
    requirements: requirements,
  }
  validateRequirementsYaml(requirements_)
  return yaml.dump(requirements_)
}

const inputFilePath = join(__dirname, 'executable-features.csv')
const labels = ['executable', 'feature']
const outputFile = join(__dirname, 'features-executable.yaml')

const content = fs.readFileSync(inputFilePath, 'utf8')
const features = getPackageExecutables(content)
const yaml_ = getRequirementsYaml(features, labels)
const outputText = endent`
    # This requirements file is not perfect but it should be a useful starting point.
    # It is intended to be copied into the saved requirements directory and then modified.
    #
    # This file was generated by '${basename(__filename)}'
    # with data from '${basename(inputFilePath)}'.

    ${yaml_}
  `
fs.writeFileSync(outputFile, outputText)
